<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TSP Game</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
/*───── Base ─────*/
body{margin:0;overflow:hidden;font-family:Arial,Helvetica,sans-serif;background:#87ceeb}

/*───── Fancy score badge ─────*/
#scoreboard{
  position:fixed;top:12px;left:50%;transform:translateX(-50%);
  display:flex;align-items:center;gap:6px;
  padding:6px 24px;border-radius:40px;
  background:rgba(255,255,255,.25);
  box-shadow:0 4px 18px rgba(0,0,0,.15);
  backdrop-filter:blur(8px);
  font:600 22px/1 "Segoe UI",Arial,sans-serif;color:#000;z-index:11
}
#score{
  font-size:26px;font-weight:700;
  background:linear-gradient(135deg,#ffb300 0%,#ffeb3b 60%,#fffde7 100%);
  -webkit-background-clip:text;color:transparent;
  text-shadow:0 1px 2px rgba(0,0,0,.25);
  transition:transform .28s cubic-bezier(.34,1.56,.64,1)
}
#score.bump{transform:scale(1.35)}

/*───── Footer info panel ─────*/
#ui{
  position:fixed;bottom:18px;left:50%;transform:translateX(-50%);
  display:flex;gap:14px;align-items:center;
  padding:8px 26px;border-radius:8px;
  background:rgba(0,0,0,.55);color:#fff;font-size:14px;
  backdrop-filter:blur(6px);z-index:10;
  width:68vw;max-width:850px;justify-content:space-between;flex-wrap:wrap
}
#ui p{margin:0}

/*───── Control button bar ─────*/
#controls{
  position:fixed;bottom:118px;left:50%;transform:translateX(-50%);
  display:flex;gap:12px;z-index:10
}
button{
  padding:4px 12px;border:0;border-radius:4px;
  background:#2196f3;color:#fff;font:bold 13px Arial;cursor:pointer;
  box-shadow:0 2px 4px rgba(0,0,0,.2);transition:background .18s
}
button:hover{background:#1e88e5}

/*───── Tooltip / fail msg─────*/
#tooltip{
  position:fixed;pointer-events:none;background:#212121;color:#fff;
  padding:4px 6px;border-radius:4px;font-size:12px;opacity:0;
  transition:opacity .15s;z-index:11;white-space:nowrap
}
#msg{
  position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);
  font-size:48px;font-weight:bold;color:#ff5252;
  text-shadow:0 0 10px #000;
  transition:transform .4s cubic-bezier(.68,-.55,.27,1.55);z-index:12
}
#msg.show{transform:translate(-50%,-50%) scale(1)}
</style>
</head>
<body>

<!-- Sleek score badge -->
<div id="scoreboard">Score&nbsp;<span id="score">0</span></div>

<!-- Control buttons -->
<div id="controls">
  <button id="reset">Restart</button>
  <button id="undo">Undo</button>
</div>

<!-- Route / gas info -->
<div id="ui">
  <p>Visit each warehouse once and come back to the starting point, while minimizing gas expenditure.</p>
  <p>Route:&nbsp;<span id="route"></span>&nbsp;|&nbsp;Gas:&nbsp;<span id="cost">0</span></p>
</div>

<div id="tooltip"></div>
<div id="msg">TRY&nbsp;AGAIN!</div>

<script type="module">
/* ───────────────── import Three.js & helpers ───────────────── */
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js?module';
import {OrbitControls} from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js?module';
import {Line2}         from 'https://unpkg.com/three@0.160.0/examples/jsm/lines/Line2.js?module';
import {LineMaterial}  from 'https://unpkg.com/three@0.160.0/examples/jsm/lines/LineMaterial.js?module';
import {LineGeometry}  from 'https://unpkg.com/three@0.160.0/examples/jsm/lines/LineGeometry.js?module';

/* ───────────────── Scene basics ───────────────── */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);
scene.fog=new THREE.Fog(0x87ceeb,85,160);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.1,1000);
camera.position.set(0,22,38);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;controls.dampingFactor=.1;
controls.target.set(0,9,0);

/* ───────────────── Lighting & skyline ───────────────── */
scene.add(new THREE.AmbientLight(0xffffff,.35));
const dl=new THREE.DirectionalLight(0xffffff,.9);
dl.position.set(14,30,10);scene.add(dl);

const skyline=new THREE.Group();
for(let i=0;i<100;i++){
  const w=2+Math.random()*4,d=2+Math.random()*4,h=8+Math.random()*27;
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),
        new THREE.MeshStandardMaterial({color:0x1a237e,flatShading:true}));
  const ang=Math.random()*Math.PI*2,dist=70+Math.random()*20;
  m.position.set(Math.cos(ang)*dist,h/2-1,Math.sin(ang)*dist);
  skyline.add(m);
}
scene.add(skyline);

/* ───────────────── Map & nodes ───────────────── */
const NODE_COUNT=6,radius=15,irregular=[1,.85,1.05,.92,1.18,.97];
const positions=[],nodes=[],edges=[];

/* Hard-coded symmetric gas costs (units) */
const costs=[
/*       0  1  2  3  4  5 */
  /*0*/ [0, 4, 7, 8, 6,10],
  /*1*/ [4, 0, 5, 6, 9, 8],
  /*2*/ [7, 5, 0, 3, 9, 5],
  /*3*/ [8, 6, 3, 0, 7, 8],
  /*4*/ [6, 9, 9, 7, 0, 4],
  /*5*/[10, 8, 5, 8, 4, 0]
];

/* Unique optimal cycle (not a simple circle) */
const OPT_ROUTE=[0,1,3,2,5,4];       // will return to 0 automatically
const key=(a,b)=>a<b?`${a}-${b}`:`${b}-${a}`;
const OPT_EDGES=new Set(OPT_ROUTE.map((v,i)=>key(v,OPT_ROUTE[(i+1)%NODE_COUNT])));

const mapGroup=new THREE.Group();mapGroup.position.y=8;scene.add(mapGroup);
const TRUCK_Y=mapGroup.position.y+0.10;
const onMap=v=>v.clone().add(mapGroup.position).setY(TRUCK_Y);

/* ───── Warehouses ───── */
function warehouse(){
  const g=new THREE.Group();
  g.add(new THREE.Mesh(new THREE.BoxGeometry(3,2,3),
        new THREE.MeshStandardMaterial({color:0x4caf50})));
  const roof=new THREE.Mesh(new THREE.ConeGeometry(2.6,1.4,4),
        new THREE.MeshStandardMaterial({color:0x795548}));
  roof.position.y=1.7;roof.rotation.y=Math.PI/4;g.add(roof);
  const gate=new THREE.Mesh(new THREE.BoxGeometry(1.6,1.2,0.15),
        new THREE.MeshStandardMaterial({color:0x3e2723}));
  gate.position.set(0,0.6,1.57);gate.userData={targetY:0.6};g.add(gate);
  g.userData.gate=gate;
  return g;
}
function startWarehouse(){
  const g=new THREE.Group();
  g.add(new THREE.Mesh(new THREE.BoxGeometry(4.5,3,4.5),
        new THREE.MeshStandardMaterial({color:0x03a9f4})));
  const roof=new THREE.Mesh(new THREE.ConeGeometry(4,2,4),
        new THREE.MeshStandardMaterial({color:0x01579b}));
  roof.position.y=2.5;roof.rotation.y=Math.PI/4;g.add(roof);
  const gate=new THREE.Mesh(new THREE.BoxGeometry(2.2,1.6,0.2),
        new THREE.MeshStandardMaterial({color:0x3e2723}));
  gate.position.set(0,0.8,2.35);gate.userData={targetY:0.8};g.add(gate);
  g.userData.gate=gate;
  return g;
}

/* ───── Create nodes ───── */
for(let i=0;i<NODE_COUNT;i++){
  const a=i/NODE_COUNT*Math.PI*2,rad=radius*irregular[i];
  const p=new THREE.Vector3(rad*Math.cos(a),0,rad*Math.sin(a));
  positions.push(p);

  const w=(i===0)?startWarehouse():warehouse();
  w.position.copy(p);w.userData.index=i;mapGroup.add(w);nodes.push(w);
}

/* ───── Roads ───── */
const roadMat=new THREE.MeshStandardMaterial({color:0x555555}),barWidth=0.35,barThickness=0.04;
for(let i=0;i<NODE_COUNT;i++)
for(let j=i+1;j<NODE_COUNT;j++){
  const a=positions[i],b=positions[j],dir=b.clone().sub(a),len=dir.length();
  const bar=new THREE.Mesh(new THREE.BoxGeometry(len,barThickness,barWidth),roadMat);
  bar.position.copy(a.clone().lerp(b,0.5)).setY(0.02);
  bar.quaternion.setFromUnitVectors(new THREE.Vector3(1,0,0),dir.normalize());
  mapGroup.add(bar);
  const pickGeo=new THREE.BufferGeometry().setFromPoints([a.clone().setY(0.02),b.clone().setY(0.02)]);
  const pick=new THREE.Line(pickGeo,new THREE.LineBasicMaterial({transparent:true,opacity:0}));
  pick.userData={i,j,gas:costs[i][j]};mapGroup.add(pick);edges.push(pick);
}

/* ───── Truck model ───── */
function truckModel(){
  const g=new THREE.Group();
  g.add(new THREE.Mesh(new THREE.BoxGeometry(2,1.3,1.8),
        new THREE.MeshStandardMaterial({color:0xef5350})));
  const cab=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.1,1.8),
        new THREE.MeshStandardMaterial({color:0xffeb3b}));
  cab.position.set(1,0.7,0);g.add(cab);
  const wheelGeo=new THREE.CylinderGeometry(0.4,0.4,0.5,20),
        wheelMat=new THREE.MeshStandardMaterial({color:0x333});
  [-0.8,0.8].forEach(z=>[-0.8,0.8].forEach(x=>{
    const w=new THREE.Mesh(wheelGeo,wheelMat);w.rotation.z=Math.PI/2;
    w.position.set(x,0.3,z);g.add(w);
  }));
  return g;
}

/* ───── UI refs & state ───── */
const scoreEl=document.getElementById('score'),routeEl=document.getElementById('route'),
      costEl=document.getElementById('cost'),tooltip=document.getElementById('tooltip'),
      msg=document.getElementById('msg');

let route=[],gas=0,closed=false,truck=null,move=null,currentWH=-1;
let score=0,nextIndex=0;

function bumpScore(){
  score++;scoreEl.textContent=score;
  scoreEl.classList.add('bump');setTimeout(()=>scoreEl.classList.remove('bump'),250);
}

/* ───── Gate & tint helpers ───── */
const tint=(i,c)=>nodes[i].children.forEach(o=>o.material?.color.set(c));
function setGate(i,open){
  const g=nodes[i].userData.gate;
  g.material.color.set(open?0x8d6e63:0x3e2723);
  g.userData.targetY=open?(i===0?2.5:2.0):(i===0?0.8:0.6);
}

/* ───── Truck movement helper ───── */
const SPEED=25;
function moveTruck(a,b){
  move={from:onMap(positions[a]),to:onMap(positions[b]),
        dur:positions[a].distanceTo(positions[b])/SPEED,el:0,dest:b};
  truck.position.copy(move.from);
}

/* ───── Game logic ───── */
function addNode(i){
  if(route.length){
    const prev=route.at(-1);
    gas+=costs[prev][i];costEl.textContent=gas.toFixed(2);
    moveTruck(prev,i);
    if(i===OPT_ROUTE[(nextIndex+1)%NODE_COUNT]){nextIndex++;bumpScore();}
  }else nextIndex=0;
  route.push(i);
  routeEl.textContent=route.join(' ➜ ');
  tint(i,0xffc107);currentWH=i;
}

/* ───── Undo feature ───── */
function undoLast(){
  if(move||!route.length)return;
  const last=route.pop();setGate(last,false);tint(last,0x4caf50);
  if(last===OPT_ROUTE[nextIndex%NODE_COUNT] && score>0){score--;scoreEl.textContent=score;nextIndex--;}
  if(route.length){
    const prev=route.at(-1);gas-=costs[prev][last];costEl.textContent=gas.toFixed(2);
    truck.position.copy(onMap(positions[prev]));currentWH=prev;
  }else{
    gas=0;costEl.textContent='0';if(truck){scene.remove(truck);truck=null;}currentWH=-1;
  }
  closed=false;routeEl.textContent=route.join(' ➜ ');
}

/* ───── Hover overlay ───── */
const RES=new THREE.Vector2(innerWidth,innerHeight);
const OVER_MAT=new LineMaterial({color:0xffff00,linewidth:0,transparent:true,opacity:1});
OVER_MAT.resolution.copy(RES);
let overlayLine=null,hoveredEdge=null,lastPointer=performance.now();
const ray=new THREE.Raycaster();ray.params.Line.threshold=0.6;
const mouse=new THREE.Vector2();
function showOverlay(a,b){
  if(!overlayLine){
    overlayLine=new Line2(new LineGeometry(),OVER_MAT);
    overlayLine.computeLineDistances();scene.add(overlayLine);
  }
  overlayLine.geometry.setPositions([a.x,a.y,a.z,b.x,b.y,b.z]);overlayLine.visible=true;
}
function hideOverlay(){overlayLine&&(overlayLine.visible=false);}
window.addEventListener('mousemove',e=>{
  mouse.x=e.clientX/innerWidth*2-1;mouse.y=-(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mouse,camera);const hit=ray.intersectObjects(edges,false);
  lastPointer=performance.now();
  if(hit.length){
    const ed=hit[0].object;
    if(ed!==hoveredEdge){
      hoveredEdge=ed;showOverlay(positions[ed.userData.i],positions[ed.userData.j]);
      tooltip.textContent=ed.userData.gas.toFixed(2)+' gas';
    }
    tooltip.style.left=e.clientX+8+'px';tooltip.style.top=e.clientY+8+'px';tooltip.style.opacity=1;
  }else tooltip.style.opacity=0;
});
function updateOverlay(){
  if(!overlayLine)return;
  const t=(performance.now()-lastPointer)<150?0.02:0;
  OVER_MAT.linewidth+=(t-OVER_MAT.linewidth)*0.15;
  if(t===0&&OVER_MAT.linewidth<0.001){hideOverlay();hoveredEdge=null;}
}

/* ───── Confetti / fail visuals ───── */
const conf=[],deb=[];
function burst(ok=true){
  const arr=ok?conf:deb,
        cols=ok?[0xffeb3b,0x2196f3,0x8bc34a,0xff9800]:[0xff5252,0xb71c1c,0x9e9e9e];
  for(let i=0;i<120;i++){
    const m=new THREE.Mesh(new THREE.PlaneGeometry(0.4,0.8),
              new THREE.MeshBasicMaterial({color:cols[Math.random()*cols.length|0],
                                           side:THREE.DoubleSide,transparent:true}));
    m.position.set(0,mapGroup.position.y+5,0);
    m.userData={v:new THREE.Vector3((Math.random()-0.5)*4,
                                   ok?Math.random()*6+3:-(Math.random()*6+3),
                                   (Math.random()-0.5)*4),
                life:2+Math.random()*1.2};
    scene.add(m);arr.push(m);
  }
}
function popMsg(){msg.classList.add('show');setTimeout(()=>msg.classList.remove('show'),1e3);}
function fail(){burst(false);setTimeout(reset,1200);}

/* ───── Evaluate closure ───── */
const setsEqual=(A,B)=>A.size===B.size&&[...A].every(x=>B.has(x));
function evaluate(){
  if(route.length!==NODE_COUNT+1||route[0]!==route.at(-1)){popMsg();fail();return;}
  const edgesPlayed=new Set();for(let k=1;k<route.length;k++)edgesPlayed.add(key(route[k-1],route[k]));
  if(setsEqual(edgesPlayed,OPT_EDGES) && nextIndex===NODE_COUNT){burst(true);}
  else{popMsg();fail();}
}

/* ───── Click handler ───── */
window.addEventListener('click',e=>{
  /* ignore clicks on panels / buttons */
  const uiRect=document.getElementById('ui').getBoundingClientRect(),
        ctrlRect=document.getElementById('controls').getBoundingClientRect();
  const insideUI =e.clientX>uiRect.left && e.clientX<uiRect.right && e.clientY>uiRect.top && e.clientY<uiRect.bottom,
        insideCtrl=e.clientX>ctrlRect.left&&e.clientX<ctrlRect.right&&e.clientY>ctrlRect.top&&e.clientY<ctrlRect.bottom;
  if(insideUI||insideCtrl)return;
  if(closed||move)return;

  mouse.x=e.clientX/innerWidth*2-1;mouse.y=-(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mouse,camera);const hit=ray.intersectObjects(nodes,true);
  if(!hit.length)return;const idx=hit[0].object.parent.userData.index;

  if(!route.length){
    if(idx!==OPT_ROUTE[0]){popMsg();return;}              // must start at node 0
    addNode(idx);truck=truckModel();truck.position.copy(onMap(positions[idx]));scene.add(truck);
    setGate(idx,true);return;
  }

  if(route.includes(idx)){
    if(idx===route[0]&&route.length===NODE_COUNT){
      addNode(idx);closed=true;moveTruck(route.at(-2),idx);return;
    }else{popMsg();return;}
  }else addNode(idx);
});

/* ───── Reset & buttons ───── */
function reset(){
  route=[];gas=0;closed=false;move=null;hideOverlay();OVER_MAT.linewidth=0;
  score=0;nextIndex=0;scoreEl.textContent=score;
  routeEl.textContent='';costEl.textContent='0';
  nodes.forEach((n,i)=>{tint(i,0x4caf50);setGate(i,false)});
  currentWH=-1;if(truck){scene.remove(truck);truck=null;}
  [...conf,...deb].forEach(p=>scene.remove(p));conf.length=deb.length=0;
  tooltip.style.opacity=0;
}
document.getElementById('reset').addEventListener('click',reset);
document.getElementById('undo').addEventListener('click',undoLast);

/* ───── Resize ───── */
window.addEventListener('resize',()=>{
  RES.set(innerWidth,innerHeight);OVER_MAT.resolution.copy(RES);
  camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

/* ───── Main loop ───── */
const clock=new THREE.Clock();
(function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();
  controls.update();updateOverlay();

  nodes.forEach(n=>{
    const g=n.userData.gate;
    g.position.y+=(g.userData.targetY-g.position.y)*0.15;
  });

  if(move){
    move.el+=dt;const t=Math.min(move.el/move.dur,1);
    truck.position.lerpVectors(move.from,move.to,t);
    truck.rotation.y=Math.atan2(move.to.x-move.from.x,move.to.z-move.from.z);
    if(t>=1){setGate(move.dest,true);move=null;if(closed)setTimeout(evaluate,150);}
  }

  [conf,deb].forEach(arr=>{
    for(let i=arr.length-1;i>=0;i--){
      const p=arr[i];p.userData.v.y-=9.8*dt*0.5;
      p.position.addScaledVector(p.userData.v,dt);
      p.rotation.x+=dt*4;p.rotation.y+=dt*5;
      p.userData.life-=dt;p.material.opacity=p.userData.life/3;
      if(p.userData.life<=0){scene.remove(p);arr.splice(i,1);}
    }
  });

  renderer.render(scene,camera);
})();
</script>
</body>
</html>
